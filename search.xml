<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Day1 - DOS, JVM, JRE, Garbage Collection</title>
    <url>/2020/04/23/Day1/</url>
    <content><![CDATA[<h4 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令:"></a>常用DOS命令:</h4><ul>
<li><p>dir：查看文件夹</p>
</li>
<li><p>md：创建文件夹</p>
</li>
<li><p>rd：删除文件夹</p>
</li>
<li><p>cd: 打开文件夹</p>
</li>
<li><p>cd .. : 返回上一级</p>
</li>
<li><p>cd: 返回根目录</p>
</li>
<li><p>del: 删除文件</p>
</li>
</ul>
<h4 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h4><ul>
<li>面向过程：对于每一个过程直接用代码实现</li>
<li>面向对象：定义一个类，可以对不同的对象进行实例化。能够更好的在抽象的层面来分析问题，同时更好的复用之前的代码，这些是面向过程很难实现的。</li>
</ul>
<h4 id="Java特性"><a href="#Java特性" class="headerlink" title="Java特性"></a>Java特性</h4><ul>
<li>解释型：先编译，再解释</li>
<li>支持多线程</li>
</ul>
<h4 id="Java两种核心机制"><a href="#Java两种核心机制" class="headerlink" title="Java两种核心机制"></a>Java两种核心机制</h4><ul>
<li><p>JVM（Java虚拟机）</p>
<p>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。对于不同的平台，有不同的虚拟机。JVM屏蔽了底层运行平台的差别，实现了‘一次编译，到处运行’。</p>
</li>
<li><p>垃圾收集机制（Garbage     Collection）GC</p>
<p>C，C++由程序员手动编写代码回收内存空间（优点：能够在内存不使用时快速回收，准确，高效；缺点：容易失误出现Bug,例如忘记编写回收内存的代码，内存一直不回收）</p>
<p>Java，垃圾回收是自动的，开了一个系统级线程自动去检测哪些内存不用了然后回收掉（优点：自动，不会出现忘记回收；缺点：回收不及时）</p>
<p>一般观点：宁可回收不及时，但是一定要回收，使用自动的垃圾回收更合适</p>
</li>
</ul>
<h4 id="什么是JDK-JRE"><a href="#什么是JDK-JRE" class="headerlink" title="什么是JDK,JRE"></a>什么是JDK,JRE</h4><ul>
<li>JDK（Java     Development Kit Java开发工具包）提供给开发人员使用，包含了java的开发工具，也包括了JRE</li>
<li>JRE（Java     Runtime Environment Java运行环境）包括Java虚拟机和Java程序所需的核心类库等。如果想要运行一个开发好的Java程序，计算机中只需安装JRE即可。</li>
<li>JDK包含JRE，JRE包含JVM</li>
</ul>
<h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><ul>
<li>步骤：</li>
<li>将Java代码编写到扩展名为.java的文件中</li>
<li>通过Javac命令对该文件进行编译</li>
<li>通过java命令对生成的class文件进行运行</li>
</ul>
<h4 id="Hello-world小结"><a href="#Hello-world小结" class="headerlink" title="Hello world小结"></a>Hello world小结</h4><ul>
<li>Java源文件以’java’为扩展名，源文件的基本组成部分是类（class）</li>
<li>Java应用程序的执行入口是main()方法。它有固定的书写格式：public static void main(String[] args){…}</li>
</ul>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>单行注释 //</li>
<li>多行注释 /**/</li>
<li>文档注释（java特有）</li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Classification</title>
    <url>/2020/04/24/Classification/</url>
    <content><![CDATA[<h4 id="K-Nearest-Neighbours"><a href="#K-Nearest-Neighbours" class="headerlink" title="K-Nearest Neighbours"></a>K-Nearest Neighbours</h4><img src="https://s1.ax1x.com/2020/04/25/JrXdPA.png" alt="K-Nearest neighbours" style="zoom: 40%;" />

<h5 id="Similarity"><a href="#Similarity" class="headerlink" title="Similarity"></a>Similarity</h5><ul>
<li><p>Euclidean distance: heavily biased towards big number - we need to normalize data first</p>
<p>We also need to avoid highly correlated features as these give extra weight to that characteristic</p>
</li>
<li><p>Jaccard Similarity: Can be used to measure the similarity between sets</p>
</li>
<li><p>Cosine similarity: Measure of angle between vectors</p>
<p>Used in text analysis - can be used to classify documents, tweets</p>
</li>
<li><p>Mahalanobis Distance</p>
</li>
<li><p>Hamming Distance</p>
</li>
</ul>
<h5 id="Algorithm-for-choosing-K"><a href="#Algorithm-for-choosing-K" class="headerlink" title="Algorithm for choosing K"></a>Algorithm for choosing K</h5><ul>
<li><p>Choose similarity or distance metric  </p>
</li>
<li><p>Divide data set into training set and test set (80/20)  </p>
</li>
<li><p>Choose evaluation metric </p>
<ul>
<li>e.g. accuracy : fraction of correctly classified instances</li>
</ul>
</li>
<li><p>Run k-NN several times with varying k </p>
<ul>
<li>Use the training set as the model   </li>
<li>Evaluate accuracy using the test set </li>
</ul>
</li>
<li><p>Optimize k by choosing the one that maximises the accuracy </p>
</li>
</ul>
<h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h5><ul>
<li><p>Supervised learning  </p>
</li>
<li><p>Classification (outputs a class)</p>
</li>
<li><p>Features need not be numeric so long a numeric distance measure can be defined  </p>
</li>
<li><p>Model</p>
<ul>
<li>Large – full data set</li>
<li>Slow to apply: in order to predict the class of a new observation, we need to get the distance of this to all the observations of the training set and then predict the class using a majority rule  </li>
</ul>
</li>
<li><p>Learning</p>
<ul>
<li>Need to choose or learn k  </li>
<li>Normalization may be required – one time transform of all data  </li>
</ul>
</li>
</ul>
<h4 id="Evaluation-Metrics"><a href="#Evaluation-Metrics" class="headerlink" title="Evaluation Metrics"></a>Evaluation Metrics</h4><ul>
<li>For binary outcomes, we define TP, FP, FN, and TN </li>
<li>ROC curve  - Receiver operating characteristic (ROC) curve  </li>
</ul>
]]></content>
      <categories>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Clustering</title>
    <url>/2020/04/25/Clustering/</url>
    <content><![CDATA[<h4 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h4><ul>
<li>Partitioning set of data points into groups which are “similar” </li>
<li>Unsupervised learning </li>
<li>Different algorithms <ul>
<li>k-means </li>
<li>Distribution based </li>
<li>Density based </li>
</ul>
</li>
</ul>
<h4 id="k-means-Clustering"><a href="#k-means-Clustering" class="headerlink" title="k-means Clustering"></a>k-means Clustering</h4><img src="https://s1.ax1x.com/2020/04/26/J6JQrd.png" alt="k-means" style="zoom: 40%;align=left" />

<h5 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h5><ul>
<li>Choose the number of clusters, k </li>
<li>Choose k random centroids (possibly k observations) </li>
<li>Repeat:  <ul>
<li>Assign each observation to nearest centroid </li>
<li>Update each centroid’s position to be mean of those observations assigned to it </li>
</ul>
</li>
<li>Until there is no, or very little, change in the centroids </li>
</ul>
<h5 id="k-means-in-practice"><a href="#k-means-in-practice" class="headerlink" title="k-means in practice"></a>k-means in practice</h5><ul>
<li>Must normalize the features so that the distances are not biased to a particular dimension </li>
<li>Need to think carefully about the features you wish to include as algorithm will give each feature equal weight <ul>
<li>Unlike linear regression where the weight may be zero, or Naïve Bayes where a meaningless feature will have no real impact </li>
</ul>
</li>
<li>Can be hard to interpret <ul>
<li>Sometimes the clusters seem meaningless </li>
</ul>
</li>
<li>Need to choose k </li>
</ul>
<h5 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h5><ul>
<li>Clusters assumed to be the same size </li>
<li>Clusters on density not so good</li>
</ul>
<h5 id="HPC-Implementation"><a href="#HPC-Implementation" class="headerlink" title="HPC Implementation"></a>HPC Implementation</h5><ul>
<li><p>All nodes get subset of the data </p>
</li>
<li><p>Repeat </p>
<ul>
<li>Centroids sent to all nodes </li>
<li>Points assigned to nearest centroid </li>
<li>For each cluster feature sums and count returned to master </li>
</ul>
</li>
<li><p>Master computes new centroids - Until centroids are stable </p>
</li>
</ul>
<h4 id="Distribution-Based-Clustering"><a href="#Distribution-Based-Clustering" class="headerlink" title="Distribution Based Clustering"></a>Distribution Based Clustering</h4><ul>
<li>Model the data using statistical distributions </li>
<li>Gaussian mixture models <ul>
<li>Model is a fixed number of Gaussian distributions </li>
<li>Need to discover the parameters of these Gaussian distributions - For each cluster need to know mean for each feature dimension and the covariance matrix </li>
</ul>
</li>
<li>Expectation maximization algorithm </li>
<li>Data points are assigned to the distribution they most likely belong to (hard clusters), or each data point is given probability of belonging to clusters (soft clusters) </li>
</ul>
<h5 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h5><ul>
<li>Handles covariance of features - No need to normalize data </li>
<li>Can choose number of clusters </li>
</ul>
<h5 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h5><ul>
<li>Bad for density based clusters that don’t match distribution model </li>
</ul>
<h4 id="Density-Based-Clustering"><a href="#Density-Based-Clustering" class="headerlink" title="Density Based Clustering"></a>Density Based Clustering</h4><ul>
<li><p>Clusters are defined as areas of higher density than the rest of the data set. Points in sparse areas are considered noise and border points </p>
</li>
<li><p>Popular method is DBSCAN algorithm: </p>
<ul>
<li><p>Density-Based Spatial Clustering of Applications with Noise </p>
</li>
<li><p>Group together points with many nearby neighbors </p>
</li>
<li><p>Points with few nearby neighbors are marked as outliers </p>
</li>
<li><p>Two parameters: </p>
<ul>
<li>ε : distance below which points are considered neighbors </li>
<li>minPts: minimum number of points required to form a cluster </li>
</ul>
</li>
<li><p>Uses “density-reachability” cluster model </p>
</li>
</ul>
</li>
</ul>
<h5 id="DBSCAN-definition"><a href="#DBSCAN-definition" class="headerlink" title="DBSCAN definition"></a>DBSCAN definition</h5><ul>
<li><p>All points are identified as one of: </p>
<ul>
<li>Core point: A point p with at least minPts points within ε of it. Those points within ε of p are directly-reachable from p </li>
<li>Density-reachable point: A point q is reachable from p if there is a path where , and is directly reachable from </li>
<li>Outlier: Point not reachable from any other point </li>
</ul>
</li>
<li><p>Points p and q are density connected if there exists a point o such that p and q are density-reachable from o. </p>
</li>
<li><p>A cluster defined as: </p>
<ul>
<li>Containing all points that are mutually density-connected </li>
<li>Also contains any points density-reachable from a point in cluster </li>
</ul>
</li>
</ul>
<h5 id="Limitation-1"><a href="#Limitation-1" class="headerlink" title="Limitation"></a>Limitation</h5><ul>
<li>Can be hard to tune parameters </li>
<li>Does not produce model that can be used to classify data </li>
<li>Cannot handle clusters with highly variable densities </li>
</ul>
]]></content>
      <categories>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>Clustering</tag>
      </tags>
  </entry>
  <entry>
    <title>Day4 - 循环，流程控制语句， 数组</title>
    <url>/2020/04/23/Day4/</url>
    <content><![CDATA[<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul>
<li>在写嵌套循环时，要尽量保证外层循环次数小于内层的循环次数</li>
</ul>
<h4 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h4><ul>
<li>break终止当前所在的循环</li>
<li>continue结束当前这次循环，直接进入下一次循环（当前循环的下面的代码不执行）</li>
<li>return结束方法</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>存放多个数据的集合</p>
<p><img src="https://s1.ax1x.com/2020/04/24/J0mDiV.png" alt="一维数组的声明"></p>
</li>
<li><p>数组内的元素都有一个引用的元素下标，这个下标是个数字，从左到右从0开始计数</p>
</li>
<li><p>每个数组都有一个属性length指明它的长度a.length</p>
</li>
<li><p>数组一旦初始化，其长度是不可变的</p>
</li>
<li><p>使用动态初始化时，数组会有默认值，数字类型的元素默认值为0，对象默认类型是null</p>
</li>
</ul>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><ul>
<li>一维数组中每一个元素都是一个数组，这样的数组就是二维数组</li>
<li>Int[] x,y[] : 特殊写法，x是一维数组，y是二维数组</li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Day3 - 运算符，流程控制语句</title>
    <url>/2020/04/23/Day3/</url>
    <content><![CDATA[<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul>
<li>单个&amp;的时候，两边都参与运算。两个&amp;的时候，如果左边为true，右边参与运算，如果左边为false，右边不参与运算。在不需要逻辑运算两边都参与运算的时候，尽量使用&amp;&amp;和||</li>
<li>异或追求的是‘异’</li>
</ul>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ul>
<li><img src="https://s1.ax1x.com/2020/04/24/J0m3Pf.png" alt="img"></li>
<li>右移除以2的n次方，左移乘以2的n次方。注意有符号右移和无符号右移的区别</li>
<li>^同位运算时，两个数字相同则为false，不相同为true</li>
<li>~运算，就是把二进制的同位翻转，0变1，1变0</li>
</ul>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><ul>
<li><p>格式：（条件表达式）？表达式1：表达式2</p>
<p>如果是true执行表达式1，如果是false执行表达式2</p>
</li>
</ul>
<h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><p><img src="https://s1.ax1x.com/2020/04/24/J0mJxg.png" alt="img"></p>
<ul>
<li>()在所有运算符里优先级最高</li>
</ul>
<h4 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h4><ul>
<li>顺序结构，if-else，switch</li>
<li>If-else可以嵌套</li>
<li>switch语句规则：switch(表达式)中表达式的返回值必须是下述几种类型之一：bytes,     short, char, int, 枚举, String。case子句中的值必须是常量，且所有case子句中的值应是不同的。break语句用来在执行完一个case分支后使程序跳出switch语句块，如果没有break，程序会顺序执行到程序结尾。break是必须写的，不然程序就从case匹配到的位置一直往下执行到结尾。</li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Day5 - 类，变量，方法，对象</title>
    <url>/2020/04/23/Day5/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/24/J0mcM4.png" alt="面向过程和面向对象"></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul>
<li><p>类有属性（类中的成员变量）和行为（类中的成员方法）</p>
</li>
<li><p>定义一个类需要思考：构成它需要什么，它能用来做什么-属性，行为</p>
</li>
<li><p>面向对象程序设计的重点是类的设计，定义类其实是定义类中的成员（成员变量和成员方法）</p>
</li>
<li><p>类只有一个，但是通过类实例出的对象可以有多个，且彼此相互独立</p>
</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><img src="https://s1.ax1x.com/2020/04/24/J0m2L9.png" alt="变量分类"></p>
<p><img src="https://s1.ax1x.com/2020/04/24/J0mfd1.png" alt="成员变量和局部变量的区别"></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>方法可以调用方法，但是方法中不能定义方法</li>
<li>同一个类中所有的方法可以直接互相调用，不用new去实例化</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><img src="https://s1.ax1x.com/2020/04/24/J0mTzD.png" alt="成员变量的初始值"></p>
<ul>
<li>我们也可以不定义对象的句柄，而直接调用这个对象的方法，这个对象叫匿名对象</li>
<li>如果对一个对象只需要一次方法调用，那么就可以使用匿名对象。我们经常将一个匿名对象作为实参传给方法调用。</li>
</ul>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ul>
<li>在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。（例外：static方法访问非static的成员变量，编译不通过）</li>
<li>在不同类中的访问机制，县创建要访问类的对象，再用对象访问类中定义的成员。</li>
</ul>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><ul>
<li>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li>
<li>参数顺序不同也可以构成重载</li>
<li>重载与返回类型及参数名称无关，只与参数个数个参数类型有关</li>
<li>重载的前提是方法名相同</li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Day2 - 命名规范，变量，运算符，数据类型</title>
    <url>/2020/04/23/Day2/</url>
    <content><![CDATA[<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul>
<li>在java语言编程的时候，在关键的地方使用的单词，体现关键的地方的含义</li>
<li>关键字所有字母都小写</li>
</ul>
<h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><ul>
<li>可能在以后被用来作为关键字的单词，java已经把这些单词预定了，这些单词尽量就不要在编程中随意使用</li>
</ul>
<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><ul>
<li>包名：多单词组成时所有字母都小写：xxxyyyzzz</li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li>
<li>常量名：所有字母都大写，多单词时每个单词用下划线链接：XXX_YYY_ZZZ</li>
</ul>
<h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><ul>
<li>数据类型 变量名 = 变量的值，例如：int i =     1</li>
<li>变量时放在内存中的，变量必须先申明再使用</li>
<li>变量的值是可以不断变化的</li>
<li>注意：声明变量过程中的=，不是数学意义上的=，在java编程中代表赋值（赋予变量值）</li>
<li>变量的作用域：一对{}中有效</li>
<li>Int m; 这样写不对，因为没有给变量初始化（第一次给变量赋值）</li>
</ul>
<h4 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h4><ul>
<li>在Java中，数据类型分为基本数据类型和引用数据类型，其中基本数据类型有8种，除了这8中之外的所有数据类型都是引用数据类型</li>
<li>整数类型：byte,     short, int, long。byte的范围-128到127之间，声明byte类型变量的时候赋值不能超过这个范围。</li>
<li>1 byte=8bit</li>
<li>byte占用1个字节，short占用2个字节，int占用4个字节，long占用8个字节</li>
<li>long类型赋值：long I =     3l 这个类型变量赋值时要在数值后面加一个l</li>
<li>浮点类型：float,     double</li>
<li>Float 类型变量赋值，值得后面加f</li>
<li>字符类型：char     char c1 =’a’ </li>
<li>布尔类型：只能用true和false</li>
<li>8 种基本数据类型：byte,int,short,long,float,double,char,bool</li>
</ul>
<h4 id="引用数据类型String"><a href="#引用数据类型String" class="headerlink" title="引用数据类型String"></a>引用数据类型String</h4><ul>
<li><p>字符串就是由0到多个字母数字符号共同组成的一个串，这个串要用英文的双引号括起来</p>
<p>String str = “hello world”</p>
</li>
<li><p>引用类型，都可以用null作为值，就是说可以在初始化时赋值为null</p>
</li>
<li><p>Int i0 =     1; int i1 =1 这种会在内存中存储两个1的值</p>
<p>String s0 = “hello”; String s1 = “hello” 这种不会在内存中存在两个“hello”，只存在一个“hello”。假设“hello”的内存地址xxxx，声明s0变量时给s0赋值”hello”实际上让s0变量引用”hello”的内存地址xxxx</p>
</li>
</ul>
<h4 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h4><ul>
<li><p>容量小的类型可以自动转换为容量大的数据类型，但是反之不可以。变量混合运算时，系统会自动转化为容量最大的数据类型。</p>
</li>
<li><p>Byte,short和char不能相互转化</p>
</li>
<li><p>任何数据类型与String相加（+）时，会自动转化成String类型</p>
<p><img src="https://s1.ax1x.com/2020/04/24/J0e03D.png" alt="image-20200423182928088"></p>
</li>
<li><p>强制类型转换：前面加（）布尔类型不能转化成其他类型</p>
</li>
</ul>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul>
<li>当整数除以整数时，会把结果的小数部分舍弃，只保留整数部分</li>
<li>%取模（取余数）</li>
<li>++和–分别是加一和减一的运算，++或者–符号在变量之前，先对变量进行运算，再取变量的值；如果++和–在变量之后，先取变量的值，再对变量进行运算</li>
<li>字符串的加号是字符串的拼接</li>
<li>char类型数据是可以做数学运算的，在做数学运算时把字符转化为ASCII码进行计算</li>
<li>字符串与其他数据类型相加时，实际上是在做字符串的拼接</li>
<li>在使用扩展运算符时，变量在参与运算时会把结果自动强制转换为当前变量的类型</li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Day9 - 代码块，内部类，final，抽象类，接口，模板方法，工厂方法</title>
    <url>/2020/04/26/Day9/</url>
    <content><![CDATA[<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>外部的类要用自己内部类的方法，得先new内部类的对象</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>如果内部类是static的，就不能再使用外部类非static的成员</li>
<li>可以声明为final的</li>
<li>和外部类不同，可以声明为private或protected</li>
<li>可以声明为abstract类，因此可以被其他的内部类继承</li>
</ul>
<h5 id="内部类有什么用？"><a href="#内部类有什么用？" class="headerlink" title="内部类有什么用？"></a>内部类有什么用？</h5><p>内部类主要是解决java不能多重继承的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiExtend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最后new A的对象，调用新增的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.testB();</span><br><span class="line">        a.testC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 想让A同时继承B和C的方法，并且重写</span></span><br><span class="line"><span class="comment"> * 可以使用内部类变相的实现类的内部继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再在A内部定义与重写方法同名的方法，通过new内部类对象来调用重写后的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerB().testB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InnerC().testC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先用两个内部类分别继承B和C，并且分别重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerB</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是重写之后的testB方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerC</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是重写之后的testC方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><h5 id="静态代码块和非静态代码块比较"><a href="#静态代码块和非静态代码块比较" class="headerlink" title="静态代码块和非静态代码块比较"></a>静态代码块和非静态代码块比较</h5><img src="https://s1.ax1x.com/2020/04/26/JgNvwQ.png" style="zoom:67%;" />

<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li><p>实际开发中，static静态代码块用在初始化类的静态属性（static类型属性）</p>
</li>
<li><p>非静态的代码块可以用来在匿名内部类中代替构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构建了一个没有类名的Person子类，也就是匿名的Person子类</span></span><br><span class="line"><span class="comment">         * 这种类没有类名，就不能显式的new方法来创建对象</span></span><br><span class="line"><span class="comment">         * 如果还需要在构造器中初始化属性就没有办法了，这种情况就要用代码块&#123;&#125;来进行初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person()&#123;<span class="comment">//一个Person的匿名子类</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 问：现在想把name改掉，但是不想动Person的代码</span></span><br><span class="line"><span class="comment">             * 在匿名内部类中，用代码块来代替构造方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">super</span>.name = <span class="string">"Anna"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"这是重写之后的test方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(p.name);<span class="comment">//会输出anna</span></span><br><span class="line">        p.test();<span class="comment">//会输出重写之后的代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在new Person()执行的时候，第一步是类的属性的默认初始化和显式初始化</span></span><br><span class="line"><span class="comment">     * 第二步是执行代码块，如果有多个代码块，会按照程序的编写顺序执行</span></span><br><span class="line"><span class="comment">     * 第三步：执行构造器的代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> TestPerson tp = <span class="keyword">new</span> TestPerson();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"lisa"</span>;</span><br><span class="line">        System.out.println(<span class="string">"这是构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"这是非静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块，这里只能使用静态修饰的属性和方法</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        showAge();</span><br><span class="line"></span><br><span class="line">        tp.age = <span class="number">12</span>;</span><br><span class="line">        tp.name = <span class="string">"ANNA"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是Person的test方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="关键字final"><a href="#关键字final" class="headerlink" title="关键字final"></a>关键字final</h4><ul>
<li>在Java中声明类、属性和方法时，可使用关键字final来修饰，表示“最终”</li>
<li>final标记的类不能被继承，标记的方法不能被重写，标记的变量（成员变量或局部变量）即成为常量。名称大写，且只能被赋值一次，不能改变</li>
<li>final和static一起修饰，就是全局常量</li>
</ul>
<h4 id="抽象类abstract-class"><a href="#抽象类abstract-class" class="headerlink" title="抽象类abstract class"></a>抽象类abstract class</h4><ul>
<li><p>用abstract关键字来修饰一个类时，这个类叫抽象类</p>
</li>
<li><p>用abstract来修饰一个方法时，该方法叫做抽象方法</p>
<p>抽象方法只有方法的声明，没有方法的实现，以分号结束</p>
</li>
<li><p>含有抽象方法的类必须被声明为抽象类</p>
</li>
<li><p>抽象类不能被实例化。抽象类是用来作为父类被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类</p>
</li>
</ul>
<h5 id="为什么抽象类不可以使用final关键字声明？"><a href="#为什么抽象类不可以使用final关键字声明？" class="headerlink" title="为什么抽象类不可以使用final关键字声明？"></a>为什么抽象类不可以使用final关键字声明？</h5><p>抽象类不能被实例化。抽象类是用来被继承的。抽象类的子类必须重写父类的构造方法，并提供方法体</p>
<h5 id="一个抽象类中可以定义构造器吗？"><a href="#一个抽象类中可以定义构造器吗？" class="headerlink" title="一个抽象类中可以定义构造器吗？"></a>一个抽象类中可以定义构造器吗？</h5><p>抽象类可以有构造方法，只是不能直接创建抽象类的实例对象</p>
<h4 id="模板方法设计模式-Template-Method"><a href="#模板方法设计模式-Template-Method" class="headerlink" title="模板方法设计模式(Template Method)"></a>模板方法设计模式(Template Method)</h4><p>抽象类体现的就是一种模板模式的设计。</p>
<ul>
<li>当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li><p>接口可以用来达到多重继承的效果</p>
</li>
<li><p>从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。</p>
</li>
<li><p>一个类可以实现多个接口，接口也可以继承其他接口</p>
</li>
<li><p>如果既有继承又有实现，那么先继承，再实现</p>
</li>
</ul>
<p>问：接口和抽象类很相似，好像接口能做的事抽象类也能做，为什么要定义接口呢？</p>
<p>父类需要稳定的抽象，如果父类总是改变，基于这个父类的子类，子类的子类都会受到影响。有时我们又确实需要给父类增加一些方法，那么就不能直接在父类上下手，只能新建一个接口，在接口上扩展方法，其他需要的子类自行去实现接口。</p>
<p>如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li><p>抽象类是对于一类事物的高度抽象，其中既有属性也有方法。接口是对方法的抽象，也就是对一系列动作的抽象。</p>
</li>
<li><p>当需要对一类事物抽象的时候，应该使用抽象类，好形成一个父类。</p>
</li>
<li><p>当需要对一系列的动作抽象的时候，就应该使用接口，需要使用这些动作的类去实现相应的接口即可。</p>
</li>
</ul>
<h4 id="工厂方法-Factory-method"><a href="#工厂方法-Factory-method" class="headerlink" title="工厂方法(Factory method)"></a>工厂方法(Factory method)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 宝马车的产品接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BWM</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品的信息介绍</span></span><br><span class="line"><span class="comment">     * 车的发动方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建具体的车的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BWM3</span> <span class="keyword">implements</span> <span class="title">BWM</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW3系"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BWM5</span> <span class="keyword">implements</span> <span class="title">BWM</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW5系"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BWM7</span> <span class="keyword">implements</span> <span class="title">BWM</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BMW7系"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 汽车生产接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BWMFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">BWM <span class="title">productBWM</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现具体的车型的生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BWM3Factory</span> <span class="keyword">implements</span> <span class="title">BWMFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BWM <span class="title">productBWM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产BWM3系"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BWM3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BWM5Factory</span> <span class="keyword">implements</span> <span class="title">BWMFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BWM <span class="title">productBWM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产BWM5系"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BWM5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BWM7Factory</span> <span class="keyword">implements</span> <span class="title">BWMFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BWM <span class="title">productBWM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产BWM7系"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BWM7();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这是开发人员b的工作</span></span><br><span class="line">        BWM b3 = <span class="keyword">new</span> BWM3Factory().productBWM();</span><br><span class="line">        BWM b5 = <span class="keyword">new</span> BWM5Factory().productBWM();</span><br><span class="line">        BWM b7 = <span class="keyword">new</span> BWM7Factory().productBWM();</span><br><span class="line"></span><br><span class="line">        b3.showInfo();</span><br><span class="line">        b5.showInfo();</span><br><span class="line">        b7.showInfo();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过工厂，把new对象隔离。通过产品的接口，可以接受不同实际产品的实现类，这样实现类的类名改变不影响其他合作人员的编程</p>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习易错点</title>
    <url>/2020/04/24/Java%E5%AD%A6%E4%B9%A0%E6%98%93%E9%94%99%E7%82%B9/</url>
    <content><![CDATA[<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>同一个类中的方法可以直接互相调用，不用定义新的对象</li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java_hints</tag>
      </tags>
  </entry>
  <entry>
    <title>Day6 - 类的构造，this关键字，JavaBean</title>
    <url>/2020/04/23/Day6/</url>
    <content><![CDATA[<h4 id="方法的参数传递"><a href="#方法的参数传递" class="headerlink" title="方法的参数传递"></a>方法的参数传递</h4><ul>
<li>Java里方法的参数传递方式只有一种：值传递。即将实际参数值的副本传入方法内，而参数本身不受影响。</li>
<li>对于基本数据类型而言，传的是栈中的值，对于引用对象而言，存的是保存在栈中的地址（实际引用对象保存在堆中）</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/04/24/J0GBnK.png" alt="JVM结构"></p>
<ul>
<li><p>基础数据类型的变量的值是保存在栈中的，引用对象的值保存在堆中，栈中保存的是该对象所在的地址</p>
</li>
<li><p>基本数据类型在参数传递的过程中，就是把实参的值复制在形参上</p>
</li>
<li><p>总结：<br>如果方法的形参是基本数据类型，那么实参（实际的数据）向形参传递参数时，就是直接传递值，把实参的值复制给形参。</p>
<p>如果方法的形参是对象，那么实参（实际的对象）向形参传递参数时，也是把值给形参，这个值是实参在栈内存中的值，也就是引用对象在堆中的地址。</p>
</li>
</ul>
<p>  Java中的包package等同于文件夹，包和文件夹一样可以有多级。多级的包使用点分隔，用“.”来指明包的层次。使用Import来导入包下面的类。</p>
<p>  Import day06.test.*</p>
<p>  如果使用同一个包下的类，Import可以省略</p>
<h4 id="面向对象的特征之一–封装和隐藏"><a href="#面向对象的特征之一–封装和隐藏" class="headerlink" title="面向对象的特征之一–封装和隐藏"></a>面向对象的特征之一–封装和隐藏</h4><p>Java中通过将数据声明为私有的(private)，再提供公共的(public)方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：</p>
<ol>
<li>隐藏一个类中不需要对外提供的实现细节</li>
<li>使用者只能通过实现制定好的方法来访问数据，可以方便地加入空值逻辑，限制对属性的不合理操作</li>
<li>便于修改，增强代码的可维护性</li>
</ol>
<h4 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h4><p>在同一个java文件中可以写多个的class，但是只有一个public的，其他的class只能是却生的</p>
<p><img src="https://s1.ax1x.com/2020/04/24/J0tWcR.png" alt="访问权限修饰符"></p>
<h4 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h4><ul>
<li>构造器分为隐式无参构造器（系统默认提供）和显式定义一个或多个构造器（无参、有参）</li>
<li>Java语言中，每个类都至少有一个构造器</li>
<li>默认构造器的修饰符与所属类的修饰符一致</li>
<li>一旦显式定义了构造器，则系统不再提供默认构造器</li>
<li>一个类可以创建多个重载的构造器</li>
<li>父类的构造器不可被子类继承</li>
<li>New 对象实际上就是调用类的构造方法</li>
</ul>
<h4 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h4><ul>
<li>构造器也叫构造方法，既然是方法，就可以重载</li>
<li>构造器重载，参数列表必须不同</li>
<li>构造器的重载，就是为了灵活创建出不同需要的对象。重载的多个构造方法实际上就是提供了多个初始化new对象的模板</li>
</ul>
<h4 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h4><ul>
<li><p>this在方法内部使用，即这个方法所属对象的引用；它在构造器内部使用，表示该构造器正在初始化的对象。</p>
</li>
<li><p>什么时候使用this？当在方法中需要用到调用该方法的对象时，就用this</p>
</li>
<li><p>当形参与成员变量重名时，如果在方法内部需要使用成员变量，必须添加this来表明该变量是类成员</p>
</li>
<li><p>在任意方法内，如果使用当前类的成员变量或成员方法，可以在其前面添加this，增强程序的阅读性</p>
</li>
<li><p>this可以作为一个类中，构造器相互调用的特殊格式</p>
<p>使用this（）必须放在构造器的首行</p>
<p>使用this调用本类中其他的构造器，保证至少有一个构造器是不用this的（实际上就是构造器不能自己调用自己）</p>
</li>
</ul>
<h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><ul>
<li>JavaBean是一种Java语言写成的可重用组件</li>
<li>不用手动生成，可以直接右键generate getter and setter</li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Day7 - 继承，多态，super，Object类</title>
    <url>/2020/04/24/Day7/</url>
    <content><![CDATA[<h4 id="面向对象特征之二：继承"><a href="#面向对象特征之二：继承" class="headerlink" title="面向对象特征之二：继承"></a>面向对象特征之二：继承</h4><h5 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a>什么是继承？</h5><ul>
<li><p>关键字：extends</p>
</li>
<li><p>把共性的东西抽取出来形成父类，实际需求的子类在继承父类的基础上写自己的特有代码</p>
</li>
<li><p>继承的出现提高了代码的复用性</p>
</li>
<li><p>不要仅为了获取其他类中的某个功能而去继承。继承是要有逻辑关系在里面的，不要随意继承。</p>
</li>
<li><p>子类不是父类的子集，而是对父类的“扩展”</p>
</li>
<li><p>子类不能直接访问父类中的私有变量（私有方法也不可以）</p>
</li>
</ul>
<h5 id="单继承和多继承"><a href="#单继承和多继承" class="headerlink" title="单继承和多继承"></a>单继承和多继承</h5><ul>
<li><p>Java只支持单继承，不允许多重继承（但是可以多层继承）</p>
<p>一个子类只能有一个父类，一个父类可以派生出多个子类</p>
</li>
</ul>
<h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><ul>
<li>在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖、在程序执行时，子类的方法将覆盖父类的方法。</li>
<li>子类重写父类的方法，只是重新编写方法体的代码。如果父类的方法是public，那么子类重写的时候就不能使用更严格的修饰符。</li>
<li>重写和被重写方法必须同时是static或者非static</li>
</ul>
<h5 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h5><p>重载：一个类可以有多个同名方法</p>
<p>重写：子类可以重新写父类的方法，覆盖父类的方法</p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ul>
<li>如果子类和父类在同一个包下，那么对于父类的成员修饰符，只要不是私有的private，那么就都可以使用</li>
<li>如果子类和父类不在同一个包下，子类只能使用父类中protected和public修饰的方法和成员变量</li>
</ul>
<h4 id="关键字super"><a href="#关键字super" class="headerlink" title="关键字super"></a>关键字super</h4><ul>
<li>在Java类中使用super来调用父类中的指定操作。可用于访问父类中定义的属性，调用父类中定义的成员方法，以及在子类构造方法中调用父类的构造器</li>
<li>尤其当子父类出现同名成员时，可以用super进行区分</li>
<li>super的追溯不仅限于直接父类，使用super，子类可以调用它之上的所有父类层级</li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li>
</ul>
<h5 id="调用父类的构造器"><a href="#调用父类的构造器" class="headerlink" title="调用父类的构造器"></a>调用父类的构造器</h5><ul>
<li>子类中所有的构造器默认都会访问父类中空参数的构造器</li>
<li>当父类中没有空参数的构造器时，子类的构造器必须通过this（参数列表）或者super（参数列表）语句指定调用本类或者父类中的相应构造器，且必须放在构造器第一行</li>
<li>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</li>
</ul>
<h4 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h4><p><img src="https://s1.ax1x.com/2020/04/24/JrFiMd.png" alt="this和super的区别"></p>
<h4 id="面向对象特征之三：多态性"><a href="#面向对象特征之三：多态性" class="headerlink" title="面向对象特征之三：多态性"></a>面向对象特征之三：多态性</h4><p>多态在Java中的两种体现：</p>
<ul>
<li><p>方法的重载和重写</p>
<p>重载：本类中的同名方法，体现相同的名称方法实现不同的逻辑</p>
<p>重写：子类对父类方法的覆盖。子类可以使用和父类相同的方法名，覆盖掉父类的逻辑。</p>
<p>父类的方法，想修改逻辑，但是有别的代码在调用父类的方法，可以考虑用子类继承父类，重写父类的方法。</p>
</li>
<li><p>对象的多态性：可以直接应用在抽象类和接口上</p>
</li>
</ul>
<h5 id="编译时类型和运行时类型"><a href="#编译时类型和运行时类型" class="headerlink" title="编译时类型和运行时类型"></a>编译时类型和运行时类型</h5><p>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定</p>
<p>若编译时类型和运行时类型不一致，就出现多态 – 对象的多态</p>
<h5 id="子类和父类的多态性"><a href="#子类和父类的多态性" class="headerlink" title="子类和父类的多态性"></a>子类和父类的多态性</h5><p><img src="https://s1.ax1x.com/2020/04/24/JrwI2T.png" alt="子类和父类的多态"></p>
<ul>
<li>一个引用类型变量如果声明为父类的类型，但实际引用的是子类的对象，那么该变量就不能再访问子类中添加的属性和方法（此时的方法是没有被重写的，无法被调用）</li>
</ul>
<h5 id="虚拟方法调用-–-必须建立在方法的重写之上"><a href="#虚拟方法调用-–-必须建立在方法的重写之上" class="headerlink" title="虚拟方法调用 – 必须建立在方法的重写之上"></a>虚拟方法调用 – 必须建立在方法的重写之上</h5><p><img src="https://s1.ax1x.com/2020/04/24/Jr0heH.png" alt="虚拟方法调用"></p>
<ul>
<li><p>成员方法的多态性，也就是动态绑定，必须得存在于方法的重写之上。（只有子类重写父类的方法，才有可能出现动态绑定）</p>
</li>
<li><p>如果子类没有重写父类的方法，那么子类就是直接使用父类的方法。</p>
<p>如果重写了，子类就使用自己重写之后的方法</p>
</li>
</ul>
<h4 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h4><p>x instanceof A：检验x是否为类A的对象，返回值为boolean型</p>
<p>要求x所属的类与类A必须是子类和父类的关系，否则编译错误</p>
<p>如果x属于类A的子类B，返回的值也为true</p>
<p>就是检验某个对象是不是类A的子类</p>
<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><ul>
<li><p>Object类是所有Java类的根父类（基类）</p>
</li>
<li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为Object类</p>
</li>
<li><p>多层继承，处于最高层的父类一定是Object类</p>
</li>
</ul>
<h5 id="Object类中的主要方法"><a href="#Object类中的主要方法" class="headerlink" title="Object类中的主要方法"></a>Object类中的主要方法</h5><ul>
<li>public Object() – 构造函数</li>
<li>public boolean equals(Object obj) – 判断两个对象是否一样</li>
<li>public int hashCode() – 取得hash码</li>
<li>public String toString() – 对象打印时调用（打印当前对象所在的地址）</li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear Regression</title>
    <url>/2020/04/24/Linear-Regression/</url>
    <content><![CDATA[<h4 id="Type-of-Machine-learning"><a href="#Type-of-Machine-learning" class="headerlink" title="Type of Machine learning"></a>Type of Machine learning</h4><ul>
<li><p>Supervised Learning</p>
<p>Where there is an input X, and an output Y and the task is to learn the mapping from the input to the output.</p>
<ul>
<li>Classification: when Y is a categorical variable (e.g. span/not spam)</li>
<li>Regression: when Y is a continuous variable.</li>
</ul>
</li>
<li><p>Unsupervised Learning: there is only input X</p>
<p>The aim is to find regularities/structure in the input space. One method is called clustering, where the aim is to find clusters or groupings of input.</p>
</li>
</ul>
<h4 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h4><img src="https://s1.ax1x.com/2020/04/25/JrqIKO.png" alt="Linear Regression" style="zoom: 50%;" />

<h5 id="How-to-set-the-cost-function"><a href="#How-to-set-the-cost-function" class="headerlink" title="How to set the cost function?"></a>How to set the cost function?</h5><ul>
<li><p>We use least squares estimation</p>
</li>
<li><img src="https://s1.ax1x.com/2020/04/25/Jrqbad.png" alt="Calculation" style="zoom:50%;" />
</li>
<li><p>Find the values of θ0 and θ1 which have minimum cost </p>
</li>
</ul>
<h5 id="Why-do-we-use-mean-the-square-error-as-our-cost-function"><a href="#Why-do-we-use-mean-the-square-error-as-our-cost-function" class="headerlink" title="Why do we use mean the square error as our cost function?"></a>Why do we use mean the square error as our cost function?</h5><p>We assume that the numeric output is the sum of a linear function of the input and a random noise and the random noise is zero mean Gaussian with constant variance</p>
<p>Then we use maximum likelihood to estimate the parameter. The theta that maximize the LHS of the equation correspond to the value that minimize the MSE. That’s why we use MSE as the cost function.</p>
<h5 id="Gradient-descent-for-linear-regression"><a href="#Gradient-descent-for-linear-regression" class="headerlink" title="Gradient descent for linear regression"></a>Gradient descent for linear regression</h5><img src="https://s1.ax1x.com/2020/04/25/JrLnLF.png" alt="Gradient descent" style="zoom:40%;" />

<h5 id="Gradient-descent-properties"><a href="#Gradient-descent-properties" class="headerlink" title="Gradient descent properties"></a>Gradient descent properties</h5><ul>
<li>‘Batch’ algorithm because each iteration looks at all the training data</li>
<li>Can be slow to converge</li>
<li>Each iteration is slow because it need to process all the training data</li>
<li>Simultaneously update parameters according to partial derivatives</li>
</ul>
<h5 id="Stochastic-gradient-descent-algorithm"><a href="#Stochastic-gradient-descent-algorithm" class="headerlink" title="Stochastic gradient descent algorithm"></a>Stochastic gradient descent algorithm</h5><ul>
<li>Not like gradient descent where we use all the training data for each iteration, this time we only randomly choose one sample to update the parameters</li>
<li>Can scale algorithms to much bigger training sets</li>
<li>Can converge more fast than gradient descent</li>
</ul>
<h5 id="Mini-batch-gradient-descent"><a href="#Mini-batch-gradient-descent" class="headerlink" title="Mini-batch gradient descent"></a>Mini-batch gradient descent</h5><ul>
<li>Hybrid between batch (update after all m records) and stochastic (update after 1 record)</li>
<li>Upgrade using batch algorithm every b&lt;m training records</li>
<li>Supports exploitation of vectorization and hence parallelism</li>
</ul>
<h4 id="Learning-process-for-supervised-learning"><a href="#Learning-process-for-supervised-learning" class="headerlink" title="Learning process for supervised learning"></a>Learning process for supervised learning</h4><ol>
<li>Define the model</li>
<li>Build the cost function</li>
<li>Optimize the cost function to find the model’s parameters<ul>
<li>Optimization algorithms: Gradient descent, Stochastic Gradient descent</li>
<li>Normal equation (in linear and multiple regression)</li>
</ul>
</li>
<li>Evaluation of the model</li>
</ol>
<h4 id="Normal-equation"><a href="#Normal-equation" class="headerlink" title="Normal equation"></a>Normal equation</h4><ul>
<li>Normal equation is analytic solution rather than iterative (use math solution)</li>
</ul>
<h5 id="Compare-the-normal-equation-and-gradient-descent-n-features-m-training-records"><a href="#Compare-the-normal-equation-and-gradient-descent-n-features-m-training-records" class="headerlink" title="Compare the normal equation and gradient descent (n features, m training records)"></a>Compare the normal equation and gradient descent (n features, m training records)</h5><ul>
<li>Gradient descent<ul>
<li>Need to choose the learning rate</li>
<li>Iterative</li>
<li>Works for large n</li>
<li>Used with many learning algorithms</li>
</ul>
</li>
<li>Normal equation<ul>
<li>No need to choose  the learning rate</li>
<li>No iterations required</li>
<li>Inverting n*n matrix can be slow for large n</li>
<li>Only works with linear regression</li>
<li>Can fail to find a solution</li>
</ul>
</li>
</ul>
<h4 id="Evaluation-of-Model"><a href="#Evaluation-of-Model" class="headerlink" title="Evaluation of Model"></a>Evaluation of Model</h4><ul>
<li>Mean Square Error (MSE) - an absolute measure, we usually work with the root mean square error</li>
<li>Residual Standard Error</li>
<li>R^2 (coefficient of determination)<ul>
<li>It is a measure of goodness of fit, estimating the proportion of variance explained by the fitted model.  </li>
<li>It ranges from 0 to 1.</li>
<li>If R2 = 1 there is a perfect fit. </li>
<li>If R2 is 0 the model has the same performance as predicting using the overall mean . </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>Linear Regression</tag>
      </tags>
  </entry>
  <entry>
    <title>Logistic Regression</title>
    <url>/2020/04/25/Logistic-Regression/</url>
    <content><![CDATA[<h4 id="Learning-process"><a href="#Learning-process" class="headerlink" title="Learning process"></a>Learning process</h4><ul>
<li>Define model </li>
<li>Build the cost function </li>
<li>Optimize the cost function to find the model’s parameters <ul>
<li>Optimization algorithms • <ul>
<li>Gradient descent</li>
<li>Stochastic Gradient descent </li>
<li>Mini-batch Stochastic Gradient descent</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Logistic-regression-limitations"><a href="#Logistic-regression-limitations" class="headerlink" title="Logistic regression limitations"></a>Logistic regression limitations</h5><ul>
<li><p>What if our data is not linearly separable? </p>
<p>Possible solution: fit with a high order polynomial </p>
<p>This is usually a bad idea, as the model may overfit the training data and therefore will be unable to generalize to new data. </p>
</li>
</ul>
<h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><ul>
<li><p>It is a parametrical model where we make assumptions on the underlying distribution of the data and build the cost function in terms of the maximum likelihood of the training set.</p>
</li>
<li><p>Features should be normalized before the learning process.</p>
</li>
<li><p>Linear models are fast to use for prediction. </p>
</li>
<li><p>Returns a probability </p>
</li>
<li><p>Bad performance in problems where observations cannot be linearly separated. </p>
<p>Example: XOR </p>
</li>
<li><p>Can use logistic regression with polynomial terms. </p>
<ul>
<li>If we include all the quadratic terms we have O(n2) features. </li>
<li>If we include all the cubic terms we have O(n3) features. </li>
<li>The algorithm will have high variance and this may lead to overfitting.  </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>Logistic Regression</tag>
      </tags>
  </entry>
  <entry>
    <title>Feature Extraction</title>
    <url>/2020/04/24/Feature-Extraction/</url>
    <content><![CDATA[<h4 id="Feature-Choosing"><a href="#Feature-Choosing" class="headerlink" title="Feature Choosing"></a>Feature Choosing</h4><p> In a 2003 paper Introduction to Variable and Feature Selection, Guyon and Elisseeff classify three approaches to feature selection: </p>
<ul>
<li><p>Filters </p>
<p>Select subsets of variables as pre-processing step before learning. </p>
</li>
<li><p>Wrappers </p>
<p>Use learning system as black box to score subsets of variables as to their predictive power.</p>
</li>
<li><p>Embedded methods</p>
<p>Feature selection is an embedded part of the learning algorithm. </p>
</li>
</ul>
<h5 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h5><ul>
<li>Rank features according to a metric or statistic </li>
<li>If we look at all features independently:<ul>
<li>Could miss important interactions </li>
<li>Could have redundant features (But unless they are absolutely correlated then likely to still be useful)</li>
</ul>
</li>
</ul>
<h5 id="Wrappers"><a href="#Wrappers" class="headerlink" title="Wrappers"></a>Wrappers</h5><ul>
<li>Use learning system as black box to score subsets of variables as to their predictive power. </li>
<li>Selection algorithms <ul>
<li>Forward selection <ul>
<li>Add features one at a time choosing the one that gives best improvement. </li>
<li>Stop when selection criterion fails to improve. </li>
</ul>
</li>
<li>Backward elimination <ul>
<li>Remove features one at a time choosing the one that gives best improvement </li>
<li>Stop when selection criterion fails to improve. </li>
</ul>
</li>
<li>Combined approach <ul>
<li>Add a few, remove the worst, repeat. </li>
<li>{A} {A,B} {A,B,C} {A,B,C,D} {A,C,D} {A,C,D,E} </li>
</ul>
</li>
</ul>
</li>
<li>Need to divide training set into two </li>
</ul>
<h5 id="Embedded-selection"><a href="#Embedded-selection" class="headerlink" title="Embedded selection"></a>Embedded selection</h5><ul>
<li>Learning algorithms explicitly select features <ul>
<li>E.g. decision or regression tree </li>
</ul>
</li>
<li>Feature Selection Criteria: <ul>
<li>Entropy / Information gain </li>
<li>Gini index </li>
<li>Reduction in Variance/Standard Deviation </li>
</ul>
</li>
<li>Decision Tree Algorithm<ul>
<li>At root node determine the information gain for each feature </li>
<li>Split the node according to the feature that gives the maximum information gain (given starting entropy for that node) </li>
<li>Repeat process again for each new node until: <ul>
<li>All entries in the node are the same class, or </li>
<li>All features are used: take a majority vote </li>
</ul>
</li>
<li>Final tree to often be pruned to avoid over-fitting </li>
</ul>
</li>
<li>Bagging -   Bootstrap AGGregation </li>
<li>Random Forest  - Very popular in medical image analysis and segmentation </li>
</ul>
]]></content>
      <categories>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>feature extraction</tag>
      </tags>
  </entry>
  <entry>
    <title>Day8 - 对象类型转换，Wrapper，static，单例设计模式</title>
    <url>/2020/04/25/Day8/</url>
    <content><![CDATA[<h4 id="对象类型转换-Casting"><a href="#对象类型转换-Casting" class="headerlink" title="对象类型转换(Casting)"></a>对象类型转换(Casting)</h4><ul>
<li><p>基本数据类型的Casting：</p>
<ul>
<li>自动类型转换：小的数据类型可以自动转换成大的数据类型</li>
<li>强制类型转换：可以把大的数据类型强制转换成小的数据类型</li>
</ul>
</li>
<li><p>对Java对象的强制类型转换称为造型</p>
<ul>
<li><p>从子类到父类的类型转换可以自动进行</p>
</li>
<li><p>从父类到子类的类型转换必须通过造型（强制类型转换）实现</p>
<p>使用instanceof进行判断</p>
</li>
<li><p>无继承关系的引用类型间的转换是非法的</p>
</li>
</ul>
</li>
</ul>
<h4 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h4><h5 id=""><a href="#" class="headerlink" title="=="></a>==</h5><ul>
<li><p>基本类型比较：只要两个变量的值相等，即为true</p>
</li>
<li><p>引用类型比较（是否指向同一个对象）：只有指向同一个对象时，==才返回true</p>
<p>用“==”进行比较时，符号两边的数据类型必须兼容（可自动转换的基本数据类型除外），否则编译出错</p>
</li>
</ul>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><ul>
<li><p>所有类都继承了Object，也就获得了equals()方法，还可以重写</p>
</li>
<li><p>只能比较引用类型，其作用与“==”相同，比较是否指向同一个对象</p>
</li>
<li><p>特例: 当用equals()方法进行比较时，对类File, String, Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象</p>
<p>原因：在这些类中重写了Object类的equals()方法</p>
<p>&lt; !–more–&gt; </p>
</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>对于对象来说</p>
<ul>
<li>特殊的类如String, File, Date， 使用==比较的是对象的地址，equals比较的是内容</li>
<li>除了特殊的类之外的其他普通的类的对象，==和equals比较的都是对象（对象的内存地址）</li>
<li>如果你想改变一个类的equals，不想用equals比较对象的内存地址，就需要重写equals方法</li>
</ul>
<h4 id="String对象的创建"><a href="#String对象的创建" class="headerlink" title="String对象的创建"></a>String对象的创建</h4><p><img src="https://s1.ax1x.com/2020/04/25/JrxU54.png" alt="String对象的创建"></p>
<h5 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h5><p>父类Object的toString方法输出当前对象的内存地址，如果想要输出类的其他信息，重写toString方法</p>
<h4 id="包装类（Wrapper）"><a href="#包装类（Wrapper）" class="headerlink" title="包装类（Wrapper）"></a>包装类（Wrapper）</h4><p>针对八种基本数据类型定义相应的引用类型–包装类（封装类）</p>
<p>有了类的特点就可以调用类中的方法</p>
<p><img src="https://s1.ax1x.com/2020/04/25/JsSyND.png" alt="包装类"></p>
<ul>
<li><p>基本数据类型包装成包装类 – 装箱 </p>
<p>Integer i = new Integer(“123”);</p>
</li>
<li><p>获得包装类对象中包装的基本类型变量 – 拆箱</p>
<p>调用包装类的.xxxValue()方法</p>
</li>
<li><p>JDK1.5之后支持自动拆箱和自动装箱</p>
</li>
</ul>
<h5 id="字符串和基本数据类型相互转换"><a href="#字符串和基本数据类型相互转换" class="headerlink" title="字符串和基本数据类型相互转换"></a>字符串和基本数据类型相互转换</h5><ul>
<li><p>字符串转其他数据类型：‘parse’</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i6 = Integer.parseInt(<span class="string">"1234567"</span>);</span><br><span class="line"><span class="keyword">float</span> f = Float.parseFloat(<span class="string">"0.45"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = Boolean.parseBoolean(<span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他数据类型转字符串：’valueof’</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = String.valueOf(<span class="number">1</span>);String str2 = String.valueOf(<span class="number">0.54</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="基本数据类型的包装类的作用"><a href="#基本数据类型的包装类的作用" class="headerlink" title="基本数据类型的包装类的作用"></a>基本数据类型的包装类的作用</h5><p>为了完成基本数据类型与字符串之间的转换</p>
<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>如果想让一个类的所有实例共享数据，就用类变量</p>
<p>类方法和类变量的构造：</p>
<p><img src="https://s1.ax1x.com/2020/04/25/Js9fTf.png" alt="类方法和类变量"></p>
<p>类变量，这种可以被所有的实例化对象共享的属性，使用起来要慎重，因为一改所有实例化对象都会改变。</p>
<p>类方法，在工具类中用的最多</p>
<ul>
<li>因为不需要实例化就可以访问static方法，因此static方法内部不能有this，也不能有super</li>
</ul>
<h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h4><p>设计模式就是在实际编程过程中，总结出来的一些解决问题的套路。</p>
<p>单例 - 只有一个实例（只有一个对象），在整个软件系统运行过程中，这个类只被实例化一次，以后无论在哪，都只调用这一个实例。</p>
<p>适用范围：实例化对象的创建需要消耗大量的时间和资源（假设构造中要执行1000行代码，要占用很大的资源，耗时很长）– 这种情况就适合适用单例模式，只new一次对象，以后一直使用这个对象</p>
<h5 id="单例设计模式-饿汉式"><a href="#单例设计模式-饿汉式" class="headerlink" title="单例设计模式 - 饿汉式"></a>单例设计模式 - 饿汉式</h5><ul>
<li>定义好私有的构造函数</li>
<li>定义好私有的类变量</li>
<li>定义好公有的getInstance()方法</li>
<li>在调用时将会一直调用已经生成的类变量</li>
</ul>
<h5 id="单例设计模式-懒汉式-（存在线程安全的问题）"><a href="#单例设计模式-懒汉式-（存在线程安全的问题）" class="headerlink" title="单例设计模式 - 懒汉式 （存在线程安全的问题）"></a>单例设计模式 - 懒汉式 （存在线程安全的问题）</h5><ul>
<li>最开始，对象是null，直到有第一个人调用，才new一个对象，之后所有调用都用这个对象</li>
<li>定义好私有的构造函数</li>
<li>定义好私有的类变量并初始化为null</li>
<li>定义好公有的getInstance()方法，在里面加一个判断</li>
</ul>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>单例模式，软件的运行有且仅有一个实例化对象（只会new一次）</p>
<p>懒汉和饿汉式的区别，就是什么时候New这个对象</p>
<ul>
<li><p>懒汉式是在第一次有人调用getInstance方法时new对象，以后再有人调用就返回第一次new好的对象</p>
</li>
<li><p>饿汉式是在类加载之后，还没有人调用的时候，就先New好一个对象，以后不论谁来调用，都是返回之前new好的那个对象</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Day10 - 集合</title>
    <url>/2020/05/04/Day10/</url>
    <content><![CDATA[<h4 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h4><ul>
<li>子类重写父类的方法时，子类不能抛出比父类方法更大范围的异常</li>
</ul>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul>
<li>Java集合类存放于java.util包中，是一个用来存放对象的容器<ul>
<li>集合只能存放对象</li>
<li>集合存放的是多个对象的引用，对象本身还是放在堆内存中的</li>
<li>集合可以存放不同类型、不同数量的数据类型</li>
</ul>
</li>
<li>Java集合可以分为Set, List和Map三大体系<ul>
<li>Set: 无序、不可重复的集合</li>
<li>List: 有序、可重复的集合</li>
<li>Map: 具有映射关系的集合</li>
</ul>
</li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。HashSet按Hash算法存储集合中的元素，因此具有很好的存取和查找性能。</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>不能保证元素的排列顺序</li>
<li>不可重复，指的是hashcode不相同</li>
<li>不是线程安全的</li>
<li>集合元素可以是null</li>
</ul>
<p>当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据hashCode值来决定该对象在HashSet中的存储位置</p>
<h5 id="判断两个元素相等"><a href="#判断两个元素相等" class="headerlink" title="判断两个元素相等"></a>判断两个元素相等</h5><p>两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法返回值也相等</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><h5 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h5><p>必须放入同样类的对象（默认会进行排序），否则可能发生类型转换异常，可以使用泛型来进行限制</p>
<h5 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h5><p>如果需要实现定制排序，则需要在创建TreeSet集合对象时，提供一个Comparator接口的实现类对象。由该Comparator对象负责集合元素的排序逻辑。</p>
<h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p>List元素有序、且可重复。集合中的每个元素都有其对应的顺序索引。</p>
<h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><p>Map用于保存具有映射关系的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组用于保存Map里的Value</p>
<p>Map中的key不允许重复</p>
<h4 id="操作集合的工具类Collections"><a href="#操作集合的工具类Collections" class="headerlink" title="操作集合的工具类Collections"></a>操作集合的工具类Collections</h4><p>Collections类中提供了多个synchronizedXxx()方法，该方法可将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Day11 - 泛型，枚举和注解</title>
    <url>/2020/05/05/Day11/</url>
    <content><![CDATA[<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>Java中的泛型，只在编译阶段有效，不会进入到运行阶段</p>
<h5 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h5><ul>
<li><p>泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(T key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>泛型方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cc</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E e;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法的泛型方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="comment">//在静态方法中，不能使用类上定义的泛型。如果要使用泛型，只能使用静态方法自己定义的泛型</span></span><br><span class="line">        <span class="comment">//System.out.println(this.e);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    public void test(String s)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无返回值的时候泛型方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T s)</span></span>&#123;</span><br><span class="line">        T t = s;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.e);<span class="comment">//在类上定义的泛型，可以在普通方法中使用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    public String test1(String s)&#123;</span></span><br><span class="line"><span class="comment">        return s;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有返回值的泛型方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">test1</span><span class="params">(T s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*    //普通的可变参数的方法</span></span><br><span class="line"><span class="comment">    public void test2(String... strs)&#123;</span></span><br><span class="line"><span class="comment">        for(String s : strs)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(s);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 形参为可变参数的泛型方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(T... strs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(T s : strs)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IB</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IB</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">test</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果实现接口时指定了接口的泛型的具体类型</span></span><br><span class="line"><span class="comment"> * 这个类实现接口的所有方法的数据类型都要变成这种类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">implements</span> <span class="title">IB</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dd dd = <span class="keyword">new</span> Dd();</span><br><span class="line">        List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        dd.test(l1);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; l2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        dd.test(l2);</span><br><span class="line"></span><br><span class="line">        List&lt;CC1&gt; lc = <span class="keyword">new</span> ArrayList&lt;CC1&gt;();</span><br><span class="line">        dd.test1(lc);</span><br><span class="line"></span><br><span class="line">        List&lt;DD1&gt; ld = <span class="keyword">new</span> ArrayList&lt;DD1&gt;();</span><br><span class="line">        dd.test1(ld);</span><br><span class="line"></span><br><span class="line">        List&lt;AA1&gt; la = <span class="keyword">new</span> ArrayList&lt;AA1&gt;();</span><br><span class="line">        dd.test2(la);</span><br><span class="line"></span><br><span class="line">        List&lt;IAimpl&gt; limpl = <span class="keyword">new</span> ArrayList&lt;IAimpl&gt;();</span><br><span class="line">        dd.test3(limpl);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dd</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要传入一个list集合，但是不确定list中的数据类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List参数的数据类型是CC1及其子类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(List&lt;? extends CC1&gt; list)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List参数的数据类型是CC1及其父类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(List&lt;? <span class="keyword">super</span> CC1&gt; list)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List参数的数据类型是IA的实现类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(List&lt;? extends IA&gt; list)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA1</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB1</span> <span class="keyword">extends</span> <span class="title">AA1</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC1</span> <span class="keyword">extends</span> <span class="title">BB1</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DD1</span> <span class="keyword">extends</span> <span class="title">CC1</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IA</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IAimpl</span> <span class="keyword">implements</span> <span class="title">IA</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h4><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当使用枚举类.枚举，相当于调用一次构造，返回的是这个类的一个对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Season spring = Season.SPRING;</span><br><span class="line">        spring.showInfo();</span><br><span class="line"></span><br><span class="line">        Season spring1 = Season.SPRING;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每次执行Season.SPRING返回的都是同一个对象</span></span><br><span class="line"><span class="comment">         * 枚举类中的每个枚举都是单例模式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(spring.equals(spring1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Season implements I&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每一个枚举都相当于调用一次构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SPRING(<span class="string">"Spring"</span>,<span class="string">"warm"</span>),<span class="comment">//调用有参的私有构造</span></span><br><span class="line">    SUMMER(<span class="string">"summer"</span>,<span class="string">"hot"</span>),</span><br><span class="line">    AUTUMN(<span class="string">"Autumn"</span>,<span class="string">"wind"</span>),</span><br><span class="line">    WINTER(<span class="string">"Winter"</span>,<span class="string">"cold"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name, String desc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">","</span> +<span class="keyword">this</span>.desc);</span><br><span class="line">        <span class="keyword">this</span>.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is to implement the method defined in the interface"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 Annotation"></a>注解 Annotation</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span>&#123;</span><br><span class="line">    <span class="comment">//此时的注解只能对属性生效</span></span><br><span class="line">    <span class="meta">@TestAnn</span>(id = <span class="number">100</span>, desc = <span class="string">"name"</span>)</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)<span class="comment">//表示注解的是属性</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//定义注解的生命周期，表示在整个程序运行周期都有效</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@interface</span> TestAnn&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
